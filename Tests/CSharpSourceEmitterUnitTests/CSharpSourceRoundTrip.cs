using System;
using System.Text;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.IO;
using Microsoft.Cci;
using CSharpSourceEmitter;

namespace CSharpSourceEmitterUnitTests {
  /// <summary>
  /// These tests verify that we can take C# source code (in the precise format
  /// generated by CSharpSourceEmitter), compile it, decompile it and have it
  /// match exactly the original source.
  /// </summary>
  [TestClass]
  public class CSharpSourceRoundTrip {

    [TestInitialize]
    public void Initialize() {

      // This is here so that there is a real reference from this assembly to the assembly that
      // is needed for the tests. Without it, it isn't copied to the directory
      // where the tests are run and the tests fail.
      var _ = new MethodModifiers.Derived();

      string assemblyName = Path.Combine(
        Path.GetDirectoryName(typeof(CSharpSourceRoundTrip).Assembly.Location),
        "CSharpSourceEmitterUnitTestInput.dll");
      Assert.IsTrue(File.Exists(assemblyName), "Can't find input file CSharpSourceEmitterUnitTestInput.dll");

      m_host = new HostEnvironment();

      // Ensure the mscorlib this test is running against is loaded
      m_host.LoadUnitFrom(typeof(object).Assembly.Location);

      m_inputAsm = m_host.LoadUnitFrom(assemblyName) as IAssembly;
      Assert.IsNotNull(m_inputAsm, "Failed to read in CSharpSourceEmitterUnitTestInput.dll");
    }
    private IAssembly m_inputAsm;
    private HostEnvironment m_host;

    /// <summary>
    /// Run all the source-round trip unit tests
    /// Conceptually these are all distinct tests, but I combine them into
    /// a single test here to avoid cluttering the CCI solution test view.
    /// </summary>
    [TestMethod]
    public void TestCSharpSourceRoundTrip() {
      TestFile("MethodModifiers");
      TestFile("Enums");
      TestFile("Properties");
    }

    // Get the source for a namespace/type at root scope
    private string Decompile(string rootName) {
      // Use CCI's formatting style for consistency
      SourceEmitterOutputString sourceEmitterOutput = new SourceEmitterOutputString(2);   
      SourceEmitter csSourceEmitter = new SourceEmitter(sourceEmitterOutput);
      csSourceEmitter.LeftCurlyOnNewLine = false;

      var members = new List<INamespaceMember>(
        m_inputAsm.UnitNamespaceRoot.GetMembersNamed(m_host.NameTable.GetNameFor(rootName), false));
      Assert.AreEqual(1, members.Count, "Didn't find one root namespace member named \"" + rootName + "\".");

      csSourceEmitter.Traverse(members[0]);

      return sourceEmitterOutput.Data;
    }
    
    // Each source file should have a root namespace member with the same name as the source file.
    // This decompiles that member and verifies it matches the contents of the source file exactly
    private void TestFile(string name) {
      var decompiledSource = Decompile(name);

      string resourceName = String.Format("CSharpSourceEmitterUnitTests.EmbeddedResources.{0}.cs", name);
      Stream resource = typeof(CSharpSourceRoundTrip).Assembly.GetManifestResourceStream(resourceName);
      Assert.IsNotNull(resource, "Failed to find expected resource: " + resourceName);
      string actualSource = new StreamReader(resource).ReadToEnd();
      
      // Not that I don't use Assert.AreEqual here because it doesn't handle long strings well
      int line, col;
      var mismatchStart = FindFirstMismatch(decompiledSource, actualSource, out line, out col);
      if (mismatchStart != -1) {
        var msg = new StringBuilder();
        msg.AppendLine(String.Format("Decompiled source doesn't match {0}.cs at line {1} column {2}", name, line, col));
        msg.AppendLine("Expected: " + SourceEmitter.QuoteString(Substring(actualSource, mismatchStart, 60)));
        msg.AppendLine("Got: " + SourceEmitter.QuoteString(Substring(decompiledSource, mismatchStart, 60)));
        msg.AppendLine();
        msg.AppendLine("Full decompiled source:");
        msg.Append(decompiledSource);
        Assert.Fail(msg.ToString());
      }
    }

    private static string Substring(string str, int start, int maxLen) 
    {
      int len = maxLen;
      if (start + len >= str.Length)
        len = str.Length - start;
      return str.Substring(start, len);
    }

    private static int FindFirstMismatch(string str1, string str2, out int line, out int col) {
      line = 1;
      col = 1;
      for (int i = 0; i < str1.Length && i < str2.Length; i++) {
        if (str1[i] != str2[i])
          return i;
        if (str1[i] == '\n') {
          line++;
          col = 1;
        } else if (str1[i] != '\r')
          col++;
      }
      if (str2.Length != str1.Length)
        return Math.Min(str1.Length, str2.Length);
      return -1;
    }
  }

  internal class HostEnvironment : MetadataReaderHost {
    PeReader peReader;
    internal HostEnvironment()
      : base(new NameTable(), new InternFactory(), 0, null, false) {
      this.peReader = new PeReader(this);
    }

    public override IUnit LoadUnitFrom(string location) {
      IUnit result = this.peReader.OpenModule(BinaryDocument.GetBinaryDocumentForFile(location, this));
      this.RegisterAsLatest(result);
      return result;
    }
  }

}
